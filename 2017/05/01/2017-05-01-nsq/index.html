<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="dsfd"><title>NSQD源码分析 | 雨天</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NSQD源码分析</h1><a id="logo" href="/.">雨天</a><p class="description">行百里者半九十</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">NSQD源码分析</h1><div class="post-meta">May 1, 2017<span> | </span><span class="category"><a href="/categories/NSQ/">NSQ</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="NSQ是什么"><a href="#NSQ是什么" class="headerlink" title="NSQ是什么"></a>NSQ是什么</h2><blockquote>
<p>NSQ is a realtime distributed messaging platform.</p>
</blockquote>
<p>NSQ是一个实时的分布式消息平台。NSQ有许多优秀的特性，比如支持没有单点故障的分布式拓扑结构，可以水平拓展，消息传递及时等。<br>同时，NSQ为消费者找到相应的生产者提供了一个发现服务，即<code>nsqlooupd</code>。<br>也为集群的管理提供了一个健壮的web界面，即<code>nsqadmin</code>。</p>
<p>另外NSQ做为消息队列的一种，有以下几种特性：</p>
<ol>
<li>消息默认不是持久化的。<br>NSQ中消息是存放在内存中的，当内存中的消息数量超过设定的值(<code>--mem-queue-size</code>)后，就会将消息持久化到磁盘。我们可以将<code>--mem-queue-size</code>设为0来保证所有消息都是持久化到磁盘的。</li>
<li>消息至少被交付一次。<br>当<code>nsqd</code>没有故障时消息会至少被交付一次，当然在许多情况下，比如客户端连接超时等，消息可能会被传递多次。</li>
<li>消息接收是无序的。</li>
<li>消费者最终会找到所有它订阅的<code>Topic</code>的生产者。<br><code>nsqlookupd</code>就是用来干这个的。</li>
</ol>
<p>参考文献: <a href="http://nsq.io/overview/features_and_guarantees.html" target="_blank" rel="external">http://nsq.io/overview/features_and_guarantees.html</a></p>
<h2 id="NSQ中的一些概念"><a href="#NSQ中的一些概念" class="headerlink" title="NSQ中的一些概念"></a>NSQ中的一些概念</h2><p>我们先来了解一下NSQ中的一些概念：<br><img src="http://www.ttlsa.com/wp-content/uploads/2015/06/nsq-1.gif" alt="NSQ中消息的流转图"></p>
<ol>
<li>nsqd<br>Nsqd是一个守护进程，用来接受和转发消息。后面会具体提到。</li>
<li>Topic<br>一个<code>Topic</code>可以理解为一个种类的消息，<code>clients</code>发布消息就是发布到某一个<code>Topic</code>。</li>
<li>Channel<br><code>Channel</code>可以理解为消费者，一个<code>Topic</code>下可能有很多的<code>Channel</code>，发布到<code>Topic</code>的消息会被发送到每一个<code>Channel</code></li>
<li>Consumer<br>一个<code>Consumer</code>在订阅<code>Topic</code>时会连接到一个指定的<code>Channel</code>，可能会有许多的<code>Consumer</code>连接到同一个<code>Channel</code>。消息只会被随机地发送给某一个<code>Consumer</code>。</li>
</ol>
<p>在这里，讲一下为啥说NSQ没有单点故障。<br><img src="http://media.tumblr.com/tumblr_mat85kr5td1qj3yp2.png" alt="NSQ拓扑机构"><br>NSQ的所有<code>clients</code>都是通过TCP与<code>nsqd</code>连接的。而且可以看出，所有<code>consumer</code>，都会与所有它订阅的<code>Topic</code>的<code>nsqd</code>连接，所以在NSQ中，没有中间人，没有代理，所以也就没有单点故障。也因为所有<code>consumer</code>都连接到所有它订阅的<code>Topic</code>的<code>nsqd</code>，NSQ的水平拓展也非常容易。而找到所有<code>nsqd</code>则是<code>lookupd</code>的功劳了。</p>
<h2 id="NSQD"><a href="#NSQD" class="headerlink" title="NSQD"></a>NSQD</h2><blockquote>
<p><code>nsqd</code> is the daemon that receives, queues, and delivers messages to clients.</p>
</blockquote>
<p>nsqd是一个守护进程，主要是处理与<code>clients</code>的连接，接收和转发消息等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NSQD <span class="keyword">struct</span> &#123;</div><div class="line">	...</div><div class="line"></div><div class="line">	topicMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Topic</div><div class="line"></div><div class="line">	lookupPeers atomic.Value</div><div class="line"></div><div class="line">	tcpListener   net.Listener</div><div class="line">	httpListener  net.Listener</div><div class="line">	httpsListener net.Listener</div><div class="line">	tlsConfig     *tls.Config</div><div class="line"></div><div class="line">	poolSize <span class="keyword">int</span></div><div class="line"></div><div class="line">	notifyChan           <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</div><div class="line">	optsNotificationChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	exitChan             <span class="keyword">chan</span> <span class="keyword">int</span></div><div class="line">	waitGroup            util.WaitGroupWrapper</div><div class="line"></div><div class="line">	ci *clusterinfo.ClusterInfo</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NSQD中主要维护了它的<code>topicMap</code>， <code>tcpListener</code>(用于处理来自<code>clients</code>的tcp连接)，<code>httpListener</code>(处理http请求)，<code>waitGroup</code>(协程间同步)等。</p>
<h3 id="NSQD启动时主要做了什么"><a href="#NSQD启动时主要做了什么" class="headerlink" title="NSQD启动时主要做了什么"></a>NSQD启动时主要做了什么</h3><ol>
<li><p>启动一个TCPServer接收tcp请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n.tcpListener = tcpListener</div><div class="line">tcpServer := &amp;tcpServer&#123;ctx: ctx&#125;</div><div class="line">n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">	protocol.TCPServer(n.tcpListener, tcpServer, n.getOpts().Logger)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>启动httpServer和httpsServer(如果需要)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">n.httpsListener = httpsListener</div><div class="line">httpsServer := newHTTPServer(ctx, <span class="literal">true</span>, <span class="literal">true</span>)</div><div class="line">n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">	http_api.Serve(n.httpsListener, httpsServer, <span class="string">"HTTPS"</span>, n.getOpts().Logger)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">n.httpListener = httpListener</div><div class="line">httpServer := newHTTPServer(ctx, <span class="literal">false</span>, n.getOpts().TLSRequired == TLSRequired)</div><div class="line">n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">	http_api.Serve(n.httpListener, httpServer, <span class="string">"HTTP"</span>, n.getOpts().Logger)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>定时处理inFlight消息(后面会提到，用来处理超时或者延迟发送的消息)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.queueScanLoop() &#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>一些其他服务，比如lookup,stats等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.lookupLoop() &#125;)</div><div class="line"><span class="keyword">if</span> n.getOpts().StatsdAddress != <span class="string">""</span> &#123;</div><div class="line">	n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.statsdLoop() &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Topic与Channel"><a href="#Topic与Channel" class="headerlink" title="Topic与Channel"></a>Topic与Channel</h2><p>在讲与<code>client</code>通信之前，先梳理一下<code>Topic</code>，<code>Channel</code>，<code>client</code>这三者之间的关系。</p>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p><code>Topic</code>主要维护了<code>channelMap</code>(所拥有的<code>channel</code>), <code>backend</code>(内存消息队列超出设置大小时的备用队列，可能是持久化到磁盘<code>diskqueue</code>，也可能是丢弃<code>dummyBackendQueue</code>)，<code>memoryMsgChan</code>(内存中的消息队列)等。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Topic <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// 64bit atomic vars need to be first for proper alignment on 32bit platforms</span></div><div class="line">	messageCount <span class="keyword">uint64</span></div><div class="line"></div><div class="line">	sync.RWMutex</div><div class="line"></div><div class="line">	name              <span class="keyword">string</span></div><div class="line">	channelMap        <span class="keyword">map</span>[<span class="keyword">string</span>]*Channel</div><div class="line">	backend           BackendQueue</div><div class="line">	memoryMsgChan     <span class="keyword">chan</span> *Message</div><div class="line">	exitChan          <span class="keyword">chan</span> <span class="keyword">int</span></div><div class="line">	channelUpdateChan <span class="keyword">chan</span> <span class="keyword">int</span></div><div class="line">	waitGroup         util.WaitGroupWrapper</div><div class="line">	exitFlag          <span class="keyword">int32</span></div><div class="line">	idFactory         *guidFactory</div><div class="line"></div><div class="line">	ephemeral      <span class="keyword">bool</span></div><div class="line">	deleteCallback <span class="function"><span class="keyword">func</span><span class="params">(*Topic)</span></span></div><div class="line">	<span class="title">deleter</span>        <span class="title">sync</span>.<span class="title">Once</span></div><div class="line"></div><div class="line">	<span class="title">paused</span>    <span class="title">int32</span></div><div class="line">	<span class="title">pauseChan</span> <span class="title">chan</span> <span class="title">bool</span></div><div class="line"></div><div class="line">	<span class="title">ctx</span> *<span class="title">context</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当NSQD接受到创建<code>Topic</code>的请求或这订阅的请求时，当<code>Topic</code>不存在，就会创建<code>Topic</code>。创建<code>Topic</code>时，除了初始化一些成员之外，还会启动一个名叫<code>messagePump</code>的协程，来处理该<code>Topic</code>的消息。<br>该协程主要是接收来自<code>backend</code>和<code>memoryMsgChan</code>的消息，然后转发给<em>每一个</em><code>channel</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTopic</span><span class="params">(topicName <span class="keyword">string</span>, ctx *context, deleteCallback <span class="keyword">func</span>(*Topic)</span>) *<span class="title">Topic</span></span> &#123;</div><div class="line">	...</div><div class="line">	t.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t.messagePump() &#125;)</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">messagePump</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> msg *Message</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> msg = &lt;-memoryMsgChan:</div><div class="line">		<span class="keyword">case</span> buf = &lt;-backendChan:</div><div class="line">			msg, err = decodeMessage(buf)</div><div class="line">		...</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> i, channel := <span class="keyword">range</span> chans &#123;</div><div class="line">			chanMsg := msg</div><div class="line">			...</div><div class="line">			err := channel.PutMessage(chanMsg)</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外，<code>Topic</code>收到消息时，会判断内存中的消息队列是否已满，如果是，则会将消息写入<code>backend</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> c.memoryMsgChan &lt;- m:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		b := bufferPoolGet() <span class="comment">// 复用buffer，减少对象生成</span></div><div class="line">		err := writeMessageToBackend(b, m, c.backend)</div><div class="line">		bufferPoolPut(b)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><code>Channel</code>中维护了一些计数器，以及跟<code>Topic</code>一样的<code>backend</code>与<code>memoryMsgChan</code>，以及正在发送途中的消息，也就是已经发送给<code>client</code>但是没有得到<code>client</code>确认的消息<code>inFlightMessages</code>等。同时还维护了该<code>channel</code>所有的<code>clients</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Channel <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// 64bit atomic vars need to be first for proper alignment on 32bit platforms</span></div><div class="line">	requeueCount <span class="keyword">uint64</span></div><div class="line">	messageCount <span class="keyword">uint64</span></div><div class="line">	timeoutCount <span class="keyword">uint64</span></div><div class="line">	...</div><div class="line">	topicName <span class="keyword">string</span></div><div class="line">	name      <span class="keyword">string</span></div><div class="line">	ctx       *context</div><div class="line"></div><div class="line">	backend BackendQueue</div><div class="line">	memoryMsgChan <span class="keyword">chan</span> *Message</div><div class="line"></div><div class="line">	<span class="comment">// state tracking</span></div><div class="line">	clients        <span class="keyword">map</span>[<span class="keyword">int64</span>]Consumer</div><div class="line">	...</div><div class="line">	<span class="comment">// Stats tracking</span></div><div class="line">	...</div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> these can be DRYd up</span></div><div class="line">	deferredMessages <span class="keyword">map</span>[MessageID]*pqueue.Item</div><div class="line">	deferredPQ       pqueue.PriorityQueue</div><div class="line">	inFlightMessages <span class="keyword">map</span>[MessageID]*Message</div><div class="line">	inFlightPQ       inFlightPqueue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="如何处理与client的tcp连接"><a href="#如何处理与client的tcp连接" class="headerlink" title="如何处理与client的tcp连接"></a>如何处理与<code>client</code>的tcp连接</h2><p>在前面已经提到，NSQD在启动时会启动一个<code>tcpServer</code>来处理与<code>client</code>的连接。在<code>tcpServer</code>中，会有<code>Handle</code>函数来处理tcp连接。当初始化连接时，会判断<code>client</code>使用的协议类型，目前只支持<code>V2</code>。最后会进入一个名叫<code>IOLoop</code>的函数与<code>client</code>进行通信。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> tcpServer <span class="keyword">struct</span> &#123;</div><div class="line">	ctx *context</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tcpServer)</span> <span class="title">Handle</span><span class="params">(clientConn net.Conn)</span></span> &#123;</div><div class="line">	...</div><div class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</div><div class="line">	_, err := io.ReadFull(clientConn, buf)</div><div class="line">	...</div><div class="line">	protocolMagic := <span class="keyword">string</span>(buf)</div><div class="line">	...</div><div class="line">	<span class="keyword">var</span> prot protocol.Protocol</div><div class="line">	<span class="keyword">switch</span> protocolMagic &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"  V2"</span>: <span class="comment">//目前只支持V2</span></div><div class="line">		prot = &amp;protocolV2&#123;ctx: p.ctx&#125;</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		protocol.SendFramedResponse(clientConn, frameTypeError, []<span class="keyword">byte</span>(<span class="string">"E_BAD_PROTOCOL"</span>))</div><div class="line">		clientConn.Close()</div><div class="line">		p.ctx.nsqd.logf(<span class="string">"ERROR: client(%s) bad protocol magic '%s'"</span>,</div><div class="line">			clientConn.RemoteAddr(), protocolMagic)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = prot.IOLoop(clientConn) <span class="comment">// 处理与client的通信</span></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		p.ctx.nsqd.logf(<span class="string">"ERROR: client(%s) - %s"</span>, clientConn.RemoteAddr(), err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="IOLoop"><a href="#IOLoop" class="headerlink" title="IOLoop"></a>IOLoop</h3><p>在IOLoop这个函数中，NSQD会与client进行通信，主要是接收client的消息，并根据client发送的消息类型来做相应的处理，比如订阅，确认消息等，并在client订阅某个channel之后给client发送消息.<br>具体：</p>
<ol>
<li><p>在一个循环中接收客户端发送回来的信息，并根据消息的指令做相应的处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">	line, err = client.Reader.ReadSlice(<span class="string">'\n'</span>)</div><div class="line">	params := bytes.Split(line, separatorBytes)</div><div class="line">	response, err = p.Exec(client, params)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">Exec</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"FIN"</span>)):</div><div class="line">		<span class="keyword">return</span> p.FIN(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"PUB"</span>)):</div><div class="line">		<span class="keyword">return</span> p.PUB(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"SUB"</span>)):</div><div class="line">		<span class="keyword">return</span> p.SUB(client, params)</div><div class="line">	...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>启动了一个messagePump的协程来处理消息队列中的消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> p.messagePump(client, messagePumpStartedChan)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在这个协程中主要处理几件主要的事情：<br>给客户端发送心跳信息：(当发送心跳失败，则断开与该<code>client</code>的连接)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> &lt;-heartbeatChan:</div><div class="line">		err = p.Send(client, frameTypeResponse, heartbeatBytes)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">goto</span> exit</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>获取消息通道中的消息，并发送给客户端，而开始获取消息通道中的消息是在客户端订阅之后，之后会再提及。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...  <span class="comment">// subChannel不为空时</span></div><div class="line">		memoryMsgChan = subChannel.memoryMsgChan</div><div class="line">		backendMsgChan = subChannel.backend.ReadChan()</div><div class="line">...</div><div class="line">...</div><div class="line"><span class="keyword">case</span> subChannel = &lt;-subEventChan: <span class="comment">// 订阅事件会将所订阅的channel发送到改go-chan，开始处理消息</span></div><div class="line">		<span class="comment">// you can't SUB anymore</span></div><div class="line">		subEventChan = <span class="literal">nil</span></div><div class="line"><span class="keyword">case</span> b := &lt;-backendMsgChan:</div><div class="line">		msg, err := decodeMessage(b)</div><div class="line">		msg.Attempts++</div><div class="line">		subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</div><div class="line">		client.SendingMessage()</div><div class="line">		err = p.SendMessage(client, msg, &amp;buf)</div><div class="line"><span class="keyword">case</span> msg := &lt;-memoryMsgChan:</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h3 id="client的重要的几种消息类型与处理方式"><a href="#client的重要的几种消息类型与处理方式" class="headerlink" title="client的重要的几种消息类型与处理方式"></a>client的重要的几种消息类型与处理方式</h3><h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h3><p>当收到client发送过来的<code>SUB</code>消息后，NSQD会获取需要订阅的<code>topic</code>和<code>channel</code>，然后将<code>client</code>添加到相应的<code>channel</code>中，然后在<code>messagePump</code>中就可以消费<code>channel</code>中的消息了：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">SUB</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	topic := p.ctx.nsqd.GetTopic(topicName)</div><div class="line">	channel := topic.GetChannel(channelName)</div><div class="line">	channel.AddClient(client.ID, client)</div><div class="line">	client.Channel = channel</div><div class="line">	<span class="comment">// update message pump</span></div><div class="line">	client.SubEventChan &lt;- channel <span class="comment">//开始消费该channel中的消息</span></div><div class="line">	<span class="keyword">return</span> okBytes, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="RDY"><a href="#RDY" class="headerlink" title="RDY"></a>RDY</h3><p><code>RDY</code>表示<code>client</code>已经准备好了接收来自NSQD的消息，<code>client</code>在发送<code>RDY</code>消息的同时，会带上一个<code>count</code>，表示一个可以接收的消息的窗口大小，有点像tcp的滑动窗口。因为当NSQD给<code>client</code>发送了消息之后，这条消息的状态就变成了<code>inFlight</code>，表示未经<code>client</code>确认，当<code>inFlight</code>的数目大于或等于<code>count</code>时，NSQD就不会给<code>client</code>发送更多的消息了。当<code>client</code>发送回来<code>FIN</code>消息时，<code>inFlight</code>数目就会减一。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">RDY</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	...</div><div class="line">	count := <span class="keyword">int64</span>(<span class="number">1</span>)</div><div class="line">	...</div><div class="line">	client.SetReadyCount(count)</div><div class="line">	...</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h3><p>当收到<code>FIN</code>消息时，表明<code>client</code>对收到某一条消息做确认。这时主要是将该消息从<code>channel</code>中的<code>inFlightPQ</code>去除，同时对<code>client</code>收到消息的条数做一个计数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">FIN</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	id, err := getMessageID(params[<span class="number">1</span>])</div><div class="line">	err = client.Channel.FinishMessage(client.ID, *id)</div><div class="line">	client.FinishedMessage()</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="PUB"><a href="#PUB" class="headerlink" title="PUB"></a>PUB</h3><p><code>PUB</code>比较简单，就是收到消息后，将该消息转发给相应的<code>Topic</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">PUB</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	...</div><div class="line">	messageBody := <span class="built_in">make</span>([]<span class="keyword">byte</span>, bodyLen)</div><div class="line">	...</div><div class="line">	topic := p.ctx.nsqd.GetTopic(topicName)</div><div class="line">	msg := NewMessage(topic.GenerateID(), messageBody)</div><div class="line">	err = topic.PutMessage(msg)</div><div class="line">	...</div><div class="line">	<span class="keyword">return</span> okBytes, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="消息发送的一些细节"><a href="#消息发送的一些细节" class="headerlink" title="消息发送的一些细节"></a>消息发送的一些细节</h3><p>NSQD在给<code>client</code>发送消息之后，会将该消息添加到该<code>channel</code>的一个叫<code>inFlightPQ</code>的优先级队列中。该优先级队列的个底层结构是数组，然后基于数组实现的小根堆。而权重则是发送消息时规定的<code>timeOut</code>的时长。<br>当NSQD在收到<code>client</code>发送过来的<code>FIN</code>确认消息之后，就会从<code>inFlightPQ</code>移除相应的消息。<br>同时，NSQD在启动时，就启动了一个协程，来定时处理每个<code>channel</code>中的<code>inFlightPQ</code>和<code>deferredPQ</code>，也就是重新将消息发送给相应的<code>Channel</code>。<br>这样，就能保证消息能至少被交付一次。</p>
<h3 id="使用sync-WaitGroup-来做协程间的同步"><a href="#使用sync-WaitGroup-来做协程间的同步" class="headerlink" title="使用sync.WaitGroup 来做协程间的同步"></a>使用sync.WaitGroup 来做协程间的同步</h3><p>在NSQ中，封装了一层<code>sync.WaitGroup</code>，来做协程之间的同步，因为go不像java，线程启动后，jvm会在用户线程都结束后才退出，而go的协程启动后，<code>main</code>并不会等协程结束才退出。所以就需要用<code>WaitGroup</code>来同步协程的执行情况。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroupWrapper <span class="keyword">struct</span> &#123;</div><div class="line">	sync.WaitGroup</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WaitGroupWrapper)</span> <span class="title">Wrap</span><span class="params">(cb <span class="keyword">func</span>()</span>)</span> &#123;</div><div class="line">	w.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		cb()</div><div class="line">		w.Done()</div><div class="line">	&#125;()</div><div class="line">&#125;</div><div class="line"></div><div class="line">n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.queueScanLoop() &#125;)</div><div class="line">...</div><div class="line">n.waitGroup.Wait()</div></pre></td></tr></table></figure></p>
<h3 id="使用sync-Pool复用缓冲池"><a href="#使用sync-Pool复用缓冲池" class="headerlink" title="使用sync.Pool复用缓冲池"></a>使用sync.Pool复用缓冲池</h3><p>因为go这种自动垃圾回收的语言有时为了减少垃圾回收的成本，可以减少对象的产生，也就是可以重用对象。<code>sync.Pool</code>就是官方提供的对象重用的工具。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bp sync.Pool</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	bp.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">		<span class="keyword">return</span> &amp;bytes.Buffer&#123;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferPoolGet</span><span class="params">()</span> *<span class="title">bytes</span>.<span class="title">Buffer</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> bp.Get().(*bytes.Buffer)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferPoolPut</span><span class="params">(b *bytes.Buffer)</span></span> &#123;</div><div class="line">	bp.Put(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NSQ使用这个工具主要是在收到消息，往消息队列中写入的时候:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">b := bufferPoolGet()</div><div class="line">err := writeMessageToBackend(b, m, t.backend)</div><div class="line">bufferPoolPut(b)</div></pre></td></tr></table></figure></p>
<h3 id="使用bufio-Reader和bufio-Writer包装net-Conn，减少内存的重复分配"><a href="#使用bufio-Reader和bufio-Writer包装net-Conn，减少内存的重复分配" class="headerlink" title="使用bufio.Reader和bufio.Writer包装net.Conn，减少内存的重复分配"></a>使用bufio.Reader和bufio.Writer包装net.Conn，减少内存的重复分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">c := &amp;clientV2&#123;</div><div class="line">	...</div><div class="line">	Reader: bufio.NewReaderSize(conn, defaultBufferSize),</div><div class="line">	Writer: bufio.NewWriterSize(conn, defaultBufferSize),</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ReadSlice does not allocate new space for the data each request</span></div><div class="line"><span class="comment">// ie. the returned slice is only valid until the next call to it</span></div><div class="line">line, err = client.Reader.ReadSlice(<span class="string">'\n'</span>)</div></pre></td></tr></table></figure>
<p>NSQ使用<code>bufio.Reader</code>来包装<code>net.Conn</code>，来减少内存的重复分配，因为<code>bufio.Reader</code>的<code>ReadSlice</code>方法可以重复利用缓冲区，这样就减少了读socket时的内存分配。</p>
<h3 id="减少-byte到string的转换"><a href="#减少-byte到string的转换" class="headerlink" title="减少[]byte到string的转换"></a>减少[]byte到string的转换</h3><p>因为<code>[]byte</code>到<code>string</code>的转换需要重新分配内存，所以在<code>NSQ</code>中很少能看到<code>string</code>类型的数据，都是<code>[]byte</code>类型。<br>比如<code>MessageID</code>就是一个<code>[16]byte</code>。因为从<code>socket</code>中读出来便是<code>[]byte</code>类型，而且为了减少<code>slice</code>到<code>[16]byte</code>的复制，使用了<code>unsafe</code>包，来将<code>slice</code>强制转换成<code>[16]byte</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MessageID [MsgIDLength]<span class="keyword">byte</span></div><div class="line"></div><div class="line"><span class="comment">// validate and cast the bytes on the wire to a message ID</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessageID</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(*MessageID, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p) != MsgIDLength &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Invalid Message ID"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> (*MessageID)(unsafe.Pointer(&amp;p[<span class="number">0</span>])), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外，Go 标准库仅仅在 <code>string</code> 上提供了数值转换方法。为了避免 <code>string</code> 的分配，<code>NSQ</code>自己实现了<code>[]byte</code>转换成数字的方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ByteToBase10</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span> &#123;</div><div class="line">	base := <span class="keyword">uint64</span>(<span class="number">10</span>)</div><div class="line"></div><div class="line">	n = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</div><div class="line">		<span class="keyword">var</span> v <span class="keyword">byte</span></div><div class="line">		d := b[i]</div><div class="line">		<span class="keyword">switch</span> &#123;</div><div class="line">		<span class="keyword">case</span> <span class="string">'0'</span> &lt;= d &amp;&amp; d &lt;= <span class="string">'9'</span>:</div><div class="line">			v = d - <span class="string">'0'</span></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			n = <span class="number">0</span></div><div class="line">			err = errBase10</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		n *= base</div><div class="line">		n += <span class="keyword">uint64</span>(v)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> n, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考： <a href="https://blog.gopheracademy.com/advent-2013/day-22-a-journey-into-nsq/" target="_blank" rel="external">A Journey Into NSQ</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/05/01/2017-05-01-nsq/" data-id="cj2amrs4a007vo5aco7syn7iw" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2016/03/25/2016-03-25-skip-list/" class="next">SkipList(跳表)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ/">NSQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lintcode/">lintcode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/problems/">problems</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/二分搜索/" style="font-size: 15px;">二分搜索</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/Deque/" style="font-size: 15px;">Deque</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SkipList/" style="font-size: 15px;">SkipList</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/2017-05-01-nsq/">NSQD源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/2016-03-25-skip-list/">SkipList(跳表)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/2016-03-22-stack-problems/">栈的一些巧妙应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/21/2016-03-21-database-engine/">数据库索引的实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-interface/">抽象类与接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-inner-class/">内部类</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-design-pattern-strategy/">设计模式之策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/2016-03-08-detail-questions/">细节题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/2016-03-08-design-pattern-iterator/">设计模式之迭代器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/2016-03-08-design-pattern-adapter/">设计模式之适配器模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://1mhz.me" title="1mhz" target="_blank">1mhz</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">雨天.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>