<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="dsfd"><title>go 基准测试和pprof的使用 | 雨天</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">go 基准测试和pprof的使用</h1><a id="logo" href="/.">雨天</a><p class="description">行百里者半九十</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">go 基准测试和pprof的使用</h1><div class="post-meta">Jun 27, 2017<span> | </span><span class="category"><a href="/categories/go/">go</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><h3 id="testing包"><a href="#testing包" class="headerlink" title="testing包"></a>testing包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 控制执行次数</span></div><div class="line"><span class="comment">// 测试工具会逐步调整b.N的值，知道单词执行的累计时间超过了`-benchtime`，默认为1s</span></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="comment">// ~ go test -bench . -benchmem -run=NONE</span></div><div class="line"><span class="comment">// testing: warning: no tests to run</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// BenchmarkAdd-4          100</span></div><div class="line"><span class="comment">// 10000</span></div><div class="line"><span class="comment">// 1000000</span></div><div class="line"><span class="comment">// 100000000</span></div><div class="line"><span class="comment">// 2000000000</span></div><div class="line"><span class="comment">// 2000000000               0.36 ns/op            0 B/op          0 allocs/op</span></div><div class="line"><span class="comment">// PASS</span></div><div class="line"><span class="comment">// ok      _/Users/wuzhenxing/Documents/dev/golang/bench   0.771s</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">    <span class="built_in">println</span>(b.N)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">        _ = add(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 控制计时器的开关</span></div><div class="line"><span class="comment">// 比如在测试函数中某些操作不需要计入基准测试的时间，可以停止，开启，重置Timer等操作</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddV2</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	time.Sleep(time.Second)</div><div class="line">	b.ResetTimer() <span class="comment">// 重置Timer</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		_ = add(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">		<span class="keyword">if</span> i == <span class="number">1</span> &#123;</div><div class="line">			b.StopTimer() <span class="comment">// 暂停Timer</span></div><div class="line">			time.Sleep(time.Second)</div><div class="line">			b.StartTimer() <span class="comment">// 开始Timer</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>testing</code>提供了一些工具，主要有<code>b.N</code>, <code>b.StartTimer()</code>, <code>b.StopTimer()</code>等。用于控制基准测试的执行次数，以及计时器。</p>
<h3 id="基准测试工具"><a href="#基准测试工具" class="headerlink" title="基准测试工具"></a>基准测试工具</h3><p>基准测试使用<code>go test</code>来运行。一些常用的参数如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-bench regexp   regexp可以是任何正则表达式，表示需要运行的基准测试函数。一般可以使用`-bench .`来执行当前目录下所有的基准测试</div><div class="line">-benchmen       在输出内容中包含基准测试的内存分配统计信息</div><div class="line">-benchtime t    t表示执行单个测试函数的累积耗时上限，默认是`1s`</div><div class="line">-cpuprofile out 输出cpu profile到指定的路径，可以使用pprof查看</div><div class="line">-memprofile out 输出内存profile到指定路径，可以使用pprof查看</div></pre></td></tr></table></figure></p>
<p>比如我们可以执行入下的命令来执行基准测试:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜  bench go test -bench . --benchmem -cpuprofile cpu.prof</div><div class="line">testing: warning: no tests to run</div><div class="line">BenchmarkAdd-4          2000000000               0.36 ns/op            0 B/op          0 allocs/op</div><div class="line">PASS</div><div class="line">ok      _/Users/wuzhenxing/Documents/dev/golang/bench   0.769s</div><div class="line">➜  bench ls # 目录下会生成bench.test的二进制文件和cpu.prof的文件</div><div class="line">bench.test    bench_test.go cpu.prof</div><div class="line"></div><div class="line">➜  bench go test -bench . --benchmem -memprofile mem.prof</div><div class="line">testing: warning: no tests to run</div><div class="line">BenchmarkAdd-4          2000000000               0.37 ns/op            0 B/op          0 allocs/op</div><div class="line">PASS</div><div class="line">ok      _/Users/wuzhenxing/Documents/dev/golang/bench   0.800s</div><div class="line">➜  bench ls # 目录下会生成bench.test的二进制文件和mem.prof的文件</div><div class="line">bench.test    bench_test.go mem.prof</div></pre></td></tr></table></figure></p>
<h2 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h2><p>pprof是go提供的性能分析工具，可以分析<code>cpu profile</code>, <code>memory profile</code>,<code>heap profile</code>, <code>block profile</code>等信息。</p>
<h3 id="cpu-profile"><a href="#cpu-profile" class="headerlink" title="cpu profile"></a>cpu profile</h3><p>在基准测试中，我们已经知道怎么生成cpu.prof文件。然后可以利用<code>go tool pprof</code>工具来查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> usage: pprof [options] [binary] &lt;profile <span class="built_in">source</span>&gt; ...</span></div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 另外的一个函数生成的基准测试文件</span></div><div class="line">go tool pprof stats.test cpu.prof</div></pre></td></tr></table></figure>
<p>使用上面的命令可以得到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(pprof) top10</div><div class="line">1750ms of 2160ms total (81.02%)</div><div class="line">Dropped 33 nodes (cum &lt;= 10.80ms)</div><div class="line">Showing top 10 nodes out of 54 (cum &gt;= 60ms)</div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">     560ms 25.93% 25.93%      560ms 25.93%  runtime.mach_semaphore_signal</div><div class="line">     290ms 13.43% 39.35%     1320ms 61.11%  runtime.mallocgc</div><div class="line">     260ms 12.04% 51.39%      260ms 12.04%  runtime.heapBitsSetType</div><div class="line">     190ms  8.80% 60.19%     1220ms 56.48%  runtime.growslice</div><div class="line">     110ms  5.09% 65.28%     1280ms 59.26%  github.com/domac/playflame/stats.addTagsToName</div><div class="line">      70ms  3.24% 68.52%       70ms  3.24%  runtime.mach_semaphore_wait</div><div class="line">      70ms  3.24% 71.76%      280ms 12.96%  runtime.makeslice</div><div class="line">      70ms  3.24% 75.00%       70ms  3.24%  runtime.mapaccess2_faststr</div><div class="line">      70ms  3.24% 78.24%       70ms  3.24%  runtime.memmove</div><div class="line">      60ms  2.78% 81.02%       60ms  2.78%  runtime.memclr</div></pre></td></tr></table></figure>
<p><code>top</code>命令可以查看每个函数的耗时。比如<code>top10</code>可以查看最好时的10个函数。</p>
<p>现在解释一下每一列的意思。</p>
<p>在默认情况下，Go语言的运行时系统会以100 Hz的的频率对CPU使用情况进行取样。也就是说每秒取样100次，即每10毫秒会取样一次。为什么使用这个频率呢？因为100 Hz既足够产生有用的数据，又不至于让系统产生停顿。并且100这个数上也很容易做换算，比如把总取样计数换算为每秒的取样数。实际上，这里所说的对CPU使用情况的取样就是对当前的Goroutine的堆栈上的程序计数器的取样。由此，我们就可以从样本记录中分析出哪些代码是计算时间最长或者说最耗CPU资源的部分了。</p>
<ol>
<li>第一列：第一列表示取样点落在该函数里的总数(不包括调用其他函数)。比如<code>github.com/domac/playflame/stats.addTagsToName</code>这个函数，总共执行时间为110ms，那么总的抽样点数为11次，占总共的5.9%(共2160ms,216次)。</li>
<li>第二列：落在该函数里取样点占总取样点的百分比。</li>
<li>第三列：<code>top10</code>的默认排序是按第一列排序，也就是按每个函数的执行时间进行排序。第三列的意思是前几行加起来的执行时间占总共执行时间的多少。比如第三行的第三列，表示前三行函数的执行时间加起来占总共执行时间的51.39%。</li>
<li>第四列：第四列表示取样点落在该函数里和它直接调用，间接调用的的函数里的总数。比如<code>github.com/domac/playflame/stats.addTagsToName</code>这个函数，总时间为1280ms，表示该函数的执行时间加上该函数调用的其他函数的执行时间共1280ms。</li>
<li>第五列：第四列的时间占总时间的百分比.</li>
</ol>
<p>从<code>top10</code>的输出里我们至少可以知道每个函数的执行时间占比以及每个函数的调用栈的执行时间的占比。如果某个函数自身的执行时间过长，那说明这个函数是否有逻辑错误，是否需要拆分。如果某个函数的调用栈的执行时间过长，是否是因为调用了过多的不需要的函数。</p>
<p>有了初步认识之后，我们可以使用图形化的界面来分析整个函数的执行过程。在这之前，我们需要安装<code>Graphviz</code>。在mac上可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install Graphviz</div></pre></td></tr></table></figure></p>
<p>安装好之后，我们可以使用<code>web</code>命令查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(pprof) web</div></pre></td></tr></table></figure></p>
<p><img src="/img/pprof1.png" alt=""></p>
<p>在上图中，我们就可以对函数的总调用过程有个比较直观的了解。现在对图中的一些箭头，方框做一个解释：</p>
<ol>
<li>每个方框代表每个函数本身的执行时间，即第一列的数据，方框越大，说明该函数本身执行时间越长。每个方框里有两行数据，第一行表示该函数本身执行时间，第二行表示该函数的调用栈（该函数以及该函数调用的其他函数）执行总时间。</li>
<li>箭头表示该函数调用下一个函数所占用的时间，箭头越粗，表示调用函数占用时间越长。</li>
</ol>
<p>可以看出，图形化的数据主要还是<code>top</code>命令里的数据。只是更直观了点。</p>
<h4 id="查看局部信息"><a href="#查看局部信息" class="headerlink" title="查看局部信息"></a>查看局部信息</h4><p>当然，如果我们可能觉得整个太庞大了，会影响我们的判断，我们有事只需要看关注的函数的执行情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(pprof) top addTagsToName</div><div class="line">1030ms of 2160ms total (47.69%)</div><div class="line">Showing top 10 nodes out of 42 (cum &gt;= 1280ms)</div><div class="line"></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">     280ms 12.96% 12.96%      620ms 28.70%  runtime.mallocgc</div><div class="line">     160ms  7.41% 20.37%      160ms  7.41%  runtime.heapBitsSetType</div><div class="line">     130ms  6.02% 26.39%      460ms 21.30%  runtime.growslice</div><div class="line">     110ms  5.09% 31.48%     1280ms 59.26%  github.com/domac/playflame/stats.addTagsToName</div><div class="line">      70ms  3.24% 34.72%      280ms 12.96%  runtime.makeslice</div><div class="line">      70ms  3.24% 37.96%       70ms  3.24%  runtime.mapaccess2_faststr</div><div class="line">      70ms  3.24% 41.20%       70ms  3.24%  runtime.memmove</div><div class="line">      60ms  2.78% 43.98%       60ms  2.78%  runtime.memclr</div><div class="line">      40ms  1.85% 45.83%      360ms 16.67%  github.com/domac/playflame/stats.BenchmarkAddTagsToName</div><div class="line">      40ms  1.85% 47.69%     1280ms 59.26%  github.com/domac/playflame/stats.TestAddTagsToName</div></pre></td></tr></table></figure>
<p>我们可以指定一个函数，这样就会只看到该函数整个调用链的执行情况。</p>
<p>这个可能看起来没啥区别，用<code>web</code>看就清楚很多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(pprof) web addTagsToName</div></pre></td></tr></table></figure>
<p><img src="/img/pprof2.png" alt=""></p>
<p>在上图中，我们就只看到了包含<code>addTagsToName</code>这个函数的调用链的信息了。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>比如我们找到了一个函数，发现它的执行时间异常，所以想看看它的每一行的执行时间是怎么样的，我们可以使用<code>list</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">ROUTINE ======================== github.com/domac/playflame/stats.addTagsToName in /Users/wuzhenxing/Documents/repos/go_projects/src/github.com/domac/playflame/stats/reporter.go</div><div class="line"></div><div class="line">     110ms      1.28s (flat, cum) 59.26% of Total</div><div class="line">         .          .     41:&#125;</div><div class="line">         .          .     42:</div><div class="line">         .          .     43:func addTagsToName(name string, tags map[string]string) string &#123;</div><div class="line">         .          .     44:   // The format we want is: host.endpoint.os.browser</div><div class="line">         .          .     45:   // if there&apos;s no host tag, then we don&apos;t use it.</div><div class="line">         .       30ms     46:   keyOrder := make([]string, 0, 4)</div><div class="line">         .          .     47:   if _, ok := tags[&quot;host&quot;]; ok &#123;</div><div class="line">      20ms       20ms     48:           keyOrder = append(keyOrder, &quot;host&quot;)</div><div class="line">         .          .     49:   &#125;</div><div class="line">      10ms      250ms     50:   keyOrder = append(keyOrder, &quot;endpoint&quot;, &quot;os&quot;, &quot;browser&quot;)</div><div class="line">         .          .     51:</div><div class="line">         .          .     52:   // We tried to pool the object, but perf didn&apos;t get better.</div><div class="line">         .          .     53:   // It&apos;s most likely due to use of defer, which itself has non-trivial overhead.</div><div class="line">      20ms      480ms     54:   buf := bufPool.Get().(*bytes.Buffer)</div><div class="line">         .          .     55:   buf.Reset()</div><div class="line">         .       40ms     56:   defer bufPool.Put(buf)</div><div class="line">         .          .     57:   //buf := &amp;bytes.Buffer&#123;&#125;</div><div class="line">         .          .     58:   buf.WriteString(name)</div><div class="line">         .          .     59:   for _, k := range keyOrder &#123;</div><div class="line">         .          .     60:           buf.WriteByte(&apos;.&apos;)</div><div class="line">         .          .     61:</div><div class="line">         .          .     62:           v, ok := tags[k]</div><div class="line">         .          .     63:           if !ok || v == &quot;&quot; &#123;</div><div class="line">         .          .     64:                   buf.WriteString(&quot;no-&quot;)</div><div class="line">         .          .     65:                   buf.WriteString(k)</div><div class="line">         .          .     66:                   continue</div><div class="line">         .          .     67:           &#125;</div><div class="line">         .          .     68:</div><div class="line">         .          .     69:           writeClean(buf, v)</div><div class="line">         .          .     70:   &#125;</div><div class="line">         .          .     71:</div><div class="line">      60ms      460ms     72:   return buf.String()</div><div class="line">         .          .     73:&#125;</div><div class="line">         .          .     74:</div><div class="line">         .          .     75:// writeClean cleans value (e.g. replaces special characters with &apos;-&apos;) and</div><div class="line">         .          .     76:// writes out the cleaned value to buf.</div><div class="line">         .          .     77:func writeClean(buf *bytes.Buffer, value string) &#123;</div></pre></td></tr></table></figure>
<p>这样我们就能知道函数的整体的执行情况了，第一列的数组表示改行的执行时间，第二列表示改行的总执行时间。</p>
<p>当然我们可以使用<code>weblist</code>在浏览器中进行查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(pprof) weblist addTagsToName</div></pre></td></tr></table></figure></p>
<p><img src="/img/pprof3.png" alt=""></p>
<p>在浏览器中，我们可以看到命令行一样的结果，但是点击每一行能够看到那一行的汇编信息。当然，使用<code>disasm</code>在命令行也可以做到。</p>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><p>为了分析不同软件或软件的不同版本使用CPU的情况，相关设计人员通常需要进行函数的堆栈性能分析。相比于定期采样获得数据的方式，利用定时中断来收集程序运行时的PC寄存器值、函数地址以及整个堆栈轨迹更加高效。目前，OProfile、gprof和SystemTap等工具都是采用该方法，给出详细的CPU使用情况报告。然而，这些工具在处理复杂的统计数据时，给出的报告往往过于繁杂、不够直观、不能直接反应分析员所需要的数据。为此，Brendan Gregg开发了专门把采样到的堆栈轨迹（Stack Trace）转化为直观图片显示的工具——Flame Graph（火焰图）。</p>
<p>火焰图既是一个开源工具，也是一种类型的图片。作为一个二维图片，火焰图的X轴代表采样总量，而Y轴代表栈深度。每个框就代表了一个栈里的函数，其宽度代表了所占用的CPU总时间。因此，比较宽的框就表示该函数运行时间较慢或被调用次数较多，从而占用的CPU时间多。通过火焰图，相关设计或分析人员就可以轻松观察到各个应用占用CPU的情况。</p>
<p><img src="/img/pprof4.png" alt=""></p>
<p>火焰图和使用pprof生成的图形相比，我们可以更直观的看到程序各个部分cpu占用的情况。</p>
<h3 id="go-torch"><a href="#go-torch" class="headerlink" title="go-torch"></a>go-torch</h3><p>uber公司开源了一个go-torch的项目，用于生成pprof文件的火焰图。</p>
<p>项目地址:<a href="https://github.com/uber/go-torch" target="_blank" rel="external">https://github.com/uber/go-torch</a></p>
<p>我们可以使用<code>go get github.com/uber/go-torch</code>的方式安装。</p>
<p>当然之前需要安装一下火焰图的工具。项目地址：<a href="https://github.com/brendangregg/FlameGraph.git" target="_blank" rel="external">https://github.com/brendangregg/FlameGraph.git</a></p>
<p>使用<code>git clone https://github.com/brendangregg/FlameGraph.git</code>将项目clone到本地，然后将路径添加到PATH.</p>
<h3 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  stats git:(master) ✗ go-torch stats.test prof.cpu</div><div class="line">INFO[13:19:53] Run pprof command: go tool pprof -raw -seconds 30 stats.test prof.cpu</div><div class="line">INFO[13:19:53] Writing svg to torch.svg</div></pre></td></tr></table></figure>
<p>使用以上命令，就可以将我们的cpu profile文件转换成火焰图。使用浏览器打开默认的torch.svg就可以看到上面的火焰图了。</p>
<p><img src="/img/pprof5.png" alt=""></p>
<p>在上图中，我们选取了一个函数，我们可以看出，横条的长度代表该函数的总执行时间,上面的层级代表该函数的调用栈的深度，每个横条上面的横条，代表该函数调用了其他函数。</p>
<p>如图所示，横条上面的空白区域，表示该函数本身的执行时间，上面的每一根横条长度，代表调用其他函数所占用的总时间。</p>
<p>所以，通过火焰图，我们可以更直观的看到，每个函数在总的执行时间中所占的比重，长度就是执行时间。而且调用栈通过叠加的方式，也可以更清楚的看到调用的关系。如果某一个函数的执行时间过长，超过了预期，我们就可以分析是本身(空白区域)还是调用其他函数的问题。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/06/27/2017-06-26-go-profile/" data-id="cj9ozpx440084mqacfi2e9682" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2017/10/07/2017-10-07-docker-ethereum/" class="pre">基于Docker的Ethereum 开发环境搭建</a><a href="/2017/06/26/2017-06-26-go-malloc/" class="next">go内存分配</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ/">NSQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lintcode/">lintcode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/problems/">problems</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/二分搜索/" style="font-size: 15px;">二分搜索</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/Deque/" style="font-size: 15px;">Deque</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SkipList/" style="font-size: 15px;">SkipList</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/07/2017-10-07-docker-ethereum/">基于Docker的Ethereum 开发环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/2017-06-26-go-profile/">go 基准测试和pprof的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/2017-06-26-go-malloc/">go内存分配</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/19/2017-06-19-ratelimiter/">Ratelimter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/03/2017-06-03-vm/">虚拟存储器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-linux-awk/">awk</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-mysql/">mysql的一些细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/2017-05-01-nsq/">NSQD源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/2016-03-25-skip-list/">SkipList(跳表)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/2016-03-22-stack-problems/">栈的一些巧妙应用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://1mhz.me" title="1mhz" target="_blank">1mhz</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">雨天.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>