<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="dsfd"><title>雨天 | 行百里者半九十</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">雨天</h1><a id="logo" href="/.">雨天</a><p class="description">行百里者半九十</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2014/11/07/2014-11-07-linux-virtual-network/">Linux网络虚拟化的一些概念</a></h1><div class="post-meta">2014-11-07</div><div class="post-content"><p>##bridge<br>Bridge（桥）是 Linux 上用来做 TCP/IP 二层协议交换的设备，与现实世界中的交换机功能相似。Bridge 设备实例可以和 Linux 上其他网络设备实例连接，既 attach 一个从设备，类似于在现实世界中的交换机和一个用户终端之间连接一根网线。当有数据到达时，Bridge 会根据报文中的 MAC</p></div><p class="readmore"><a href="/2014/11/07/2014-11-07-linux-virtual-network/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/01/2014-11-1-leetcode-Clone-Graph/">DFS,图: Clone Graph</a></h1><div class="post-meta">2014-11-01</div><div class="post-content"><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, UndirectedGraphNode *&gt; nodes;  <span class="comment">//定义一个map来存储label与相对应的node指针</span></div><div class="line"></div><div class="line">    <span class="comment">//使用DFS来拷贝图</span></div><div class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</div><div class="line">        <span class="comment">//！重要，如果node为空，直接返回空指针</span></div><div class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="comment">//这里不能使用UndirectedGraphNode root(node-&gt;label)，然后返回地址，</span></div><div class="line">        <span class="comment">//这样会出现runtime error</span></div><div class="line">        UndirectedGraphNode *root = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</div><div class="line">        nodes.insert(make_pair(node-&gt;label, root));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.size(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> label = node-&gt;neighbors[i]-&gt;label;</div><div class="line">            <span class="keyword">if</span> (nodes.count(label) != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//如果遍历过了，加入nieghbors</span></div><div class="line">                root-&gt;neighbors.push_back(nodes[label]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果没有遍历过，拷贝该节点</span></div><div class="line">                root-&gt;neighbors.push_back(cloneGraph(node-&gt;neighbors[i]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/11/01/2014-11-1-leetcode-Clone-Graph/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/30/2014-10-30-dag-shortest-path/">图: DAG中使用拓扑排序来求单源点最短路径</a></h1><div class="post-meta">2014-10-30</div><div class="post-content"><p>求单源点最短路径时，使用Bellman-Ford算法的需要对所有边松弛V-1遍。但是如果我们知道一个图是一个有向无环图时，我们先对所有顶点进行一次拓扑排序，然后依次对每个顶点连接的边松弛一遍就可以了。时间复杂度为O(V+E)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DAG-SHORTEST-PATHS(G, w, s)</div><div class="line">	topologically sort the vetices of G</div><div class="line">	INITIALIZE-SINGLE-SOURCE(G,s)</div><div class="line">	for each vertex u, taken in topolocially sorted order</div><div class="line">		do for each vertex v in Adj[u]</div><div class="line">			dor Relax(u, v, w)</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/30/2014-10-30-dag-shortest-path/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/30/2014-10-30-throw-disks/">扔盘子问题</a></h1><div class="post-meta">2014-10-30</div><div class="post-content"><p>题目链接：<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1279" target="_blank" rel="external">扔盘子</a></p>
<p>The story is about throwing concrete disks into an old dry well. The well is made of concrete rings that can have different (internal) diameters. The disks fall until they hit the bottom, the previously dropped disk or the concrete ring (whose internal diameter is smaller then the disk’s diameter). You are given two arrays, A containing the diameters of the rings in the top-down order, and B containing the the diameters of the disks. The task is to compute how many disks will fit into the well?</p></div><p class="readmore"><a href="/2014/10/30/2014-10-30-throw-disks/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/28/2014-10-28-bellman-ford/">图:单源点最短路径之Bellman-Ford算法</a></h1><div class="post-meta">2014-10-28</div><div class="post-content"><p>Bellman-Ford算法能够在一般的情况下(存在负权边的情况)， 解决单源点最短路径问题，而且能够判断图中是否存在负值回路。</p>
<p>算法用到了两个辅助数组D,P。使用D来记录源点到各个点得最短距离。使用P来记录最短路的路径。</p>
<p>算法的思路如下:</p>
<ol>
<li>对两个数组进行初始化，将D[0]赋值为0，表示是以0号顶点为源点。</li></div><p class="readmore"><a href="/2014/10/28/2014-10-28-bellman-ford/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/26/2014-10-26-kruskal/">图:最小生成树之kruskal算法</a></h1><div class="post-meta">2014-10-26</div><div class="post-content"><p>kruskal法是一种贪心算法，与prim算法相似。</p>
<p>在kruskal算法中，我们用到了并查集。</p>
<p>算法的思想是这样的:</p>
<ol>
<li>对所有的顶点建立一个并查集，对所有的边先进行排序</li></div><p class="readmore"><a href="/2014/10/26/2014-10-26-kruskal/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/26/2014-10-26-Balanced-Lineup/">线段树、平方分割:POJ 3264 Balanced Lineup</a></h1><div class="post-meta">2014-10-26</div><div class="post-content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_HEIGHT = <span class="number">2000000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN_HEIGHT = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span>;</div><div class="line"><span class="keyword">int</span> N, Q;</div><div class="line"><span class="keyword">int</span> H[MAX_N + <span class="number">1</span>];</div><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; bucket; <span class="comment">//first存储最大值，second存储最小值</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;Q;</div><div class="line">    <span class="keyword">int</span> bucket_size = <span class="built_in">sqrt</span>((<span class="keyword">float</span>)N);</div><div class="line">    bucket.resize(bucket_size + <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bucket_size; i++) &#123;</div><div class="line">        bucket[i].first = MIN_HEIGHT;</div><div class="line">        bucket[i].second = MAX_HEIGHT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;H[i];</div><div class="line">        bucket[i / bucket_size].first = max(bucket[i / bucket_size].first, H[i]);</div><div class="line">        bucket[i / bucket_size].second = min(bucket[i / bucket_size].second, H[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++) &#123;</div><div class="line">        <span class="keyword">int</span> A, B;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B;</div><div class="line">        <span class="keyword">if</span> (A == B) &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> daming = MIN_HEIGHT, xiaoming = MAX_HEIGHT;</div><div class="line"></div><div class="line">        <span class="comment">//如果A、B在一个桶</span></div><div class="line">        <span class="keyword">while</span> (A &lt;= B &amp;&amp; A % bucket_size != <span class="number">0</span>) &#123;</div><div class="line">            daming = max(H[A], daming);</div><div class="line">            xiaoming = min(H[A], xiaoming);</div><div class="line">            A++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (A &lt;= B &amp;&amp; (B + <span class="number">1</span>) % bucket_size != <span class="number">0</span>) &#123;</div><div class="line">            daming = max(H[B], daming);</div><div class="line">            xiaoming = min(H[B], xiaoming);</div><div class="line">            B--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (A &lt;= B) &#123;</div><div class="line">            daming = max(bucket[A/bucket_size].first, daming);</div><div class="line">            xiaoming = min(bucket[A/bucket_size].second, xiaoming);</div><div class="line">            A += bucket_size;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;(daming - xiaoming)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/26/2014-10-26-Balanced-Lineup/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/26/2014-10-26-union-find/">图:并查集</a></h1><div class="post-meta">2014-10-26</div><div class="post-content"><p>并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。</p>
<p>并查集一般支持两种操作：</p>
<ol>
<li>查找    查询两个元素a和b是否在同一个集合</li>
<li>合并    合并a和b所在的两个集合</li></div><p class="readmore"><a href="/2014/10/26/2014-10-26-union-find/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/25/2014-10-25-prim-mst/">图:最小生成树之Prim算法</a></h1><div class="post-meta">2014-10-25</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">贪心算法之最小生成树</div><div class="line"></div><div class="line">伪代码：</div><div class="line">MST-PRIM（G, w, r）</div><div class="line">for each u in V[G]</div><div class="line">    do key[u] &lt;- INF</div><div class="line">    pi[u] &lt;- NIL</div><div class="line">key[r] &lt;- 0</div><div class="line">Q &lt;- V[G]</div><div class="line">while Q != EMPTY</div><div class="line">    do u &lt;- EXTRACT-MIN(Q)</div><div class="line">    for each v in Adj[u]</div><div class="line">        do if v in Q and w(u, v) &lt; key[v]</div><div class="line">            then pi[v] &lt;- u</div><div class="line">            key[v] = w(u,v)</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/25/2014-10-25-prim-mst/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-23-Topological-sorting/">图：拓扑排序(Topological sort)</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><p>由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。</p>
<ul>
<li>每个顶点出现且只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li>
</ul></div><p class="readmore"><a href="/2014/10/23/2014-10-23-Topological-sorting/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/7/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ/">NSQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lintcode/">lintcode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/problems/">problems</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/二分搜索/" style="font-size: 15px;">二分搜索</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/Deque/" style="font-size: 15px;">Deque</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SkipList/" style="font-size: 15px;">SkipList</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/19/2017-06-19-ratelimiter/">Ratelimter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/03/2017-06-03-vm/">虚拟存储器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-linux-awk/">awk</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-mysql/">mysql的一些细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/2017-05-01-nsq/">NSQD源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/2016-03-25-skip-list/">SkipList(跳表)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/2016-03-22-stack-problems/">栈的一些巧妙应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/21/2016-03-21-database-engine/">数据库索引的实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-interface/">抽象类与接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-inner-class/">内部类</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://1mhz.me" title="1mhz" target="_blank">1mhz</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">雨天.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>