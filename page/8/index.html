<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="dsfd"><title>雨天 | 行百里者半九十</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">雨天</h1><a id="logo" href="/.">雨天</a><p class="description">行百里者半九十</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2014/10/30/2014-10-30-dag-shortest-path/">图: DAG中使用拓扑排序来求单源点最短路径</a></h1><div class="post-meta">2014-10-30</div><div class="post-content"><p>求单源点最短路径时，使用Bellman-Ford算法的需要对所有边松弛V-1遍。但是如果我们知道一个图是一个有向无环图时，我们先对所有顶点进行一次拓扑排序，然后依次对每个顶点连接的边松弛一遍就可以了。时间复杂度为O(V+E)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DAG-SHORTEST-PATHS(G, w, s)</div><div class="line">	topologically sort the vetices of G</div><div class="line">	INITIALIZE-SINGLE-SOURCE(G,s)</div><div class="line">	for each vertex u, taken in topolocially sorted order</div><div class="line">		do for each vertex v in Adj[u]</div><div class="line">			dor Relax(u, v, w)</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/30/2014-10-30-dag-shortest-path/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/30/2014-10-30-throw-disks/">扔盘子问题</a></h1><div class="post-meta">2014-10-30</div><div class="post-content"><p>题目链接：<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1279" target="_blank" rel="external">扔盘子</a></p>
<p>The story is about throwing concrete disks into an old dry well. The well is made of concrete rings that can have different (internal) diameters. The disks fall until they hit the bottom, the previously dropped disk or the concrete ring (whose internal diameter is smaller then the disk’s diameter). You are given two arrays, A containing the diameters of the rings in the top-down order, and B containing the the diameters of the disks. The task is to compute how many disks will fit into the well?</p></div><p class="readmore"><a href="/2014/10/30/2014-10-30-throw-disks/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/28/2014-10-28-bellman-ford/">图:单源点最短路径之Bellman-Ford算法</a></h1><div class="post-meta">2014-10-28</div><div class="post-content"><p>Bellman-Ford算法能够在一般的情况下(存在负权边的情况)， 解决单源点最短路径问题，而且能够判断图中是否存在负值回路。</p>
<p>算法用到了两个辅助数组D,P。使用D来记录源点到各个点得最短距离。使用P来记录最短路的路径。</p>
<p>算法的思路如下:</p>
<ol>
<li>对两个数组进行初始化，将D[0]赋值为0，表示是以0号顶点为源点。</li></div><p class="readmore"><a href="/2014/10/28/2014-10-28-bellman-ford/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/26/2014-10-26-kruskal/">图:最小生成树之kruskal算法</a></h1><div class="post-meta">2014-10-26</div><div class="post-content"><p>kruskal法是一种贪心算法，与prim算法相似。</p>
<p>在kruskal算法中，我们用到了并查集。</p>
<p>算法的思想是这样的:</p>
<ol>
<li>对所有的顶点建立一个并查集，对所有的边先进行排序</li></div><p class="readmore"><a href="/2014/10/26/2014-10-26-kruskal/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/26/2014-10-26-Balanced-Lineup/">线段树、平方分割:POJ 3264 Balanced Lineup</a></h1><div class="post-meta">2014-10-26</div><div class="post-content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_HEIGHT = <span class="number">2000000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN_HEIGHT = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span>;</div><div class="line"><span class="keyword">int</span> N, Q;</div><div class="line"><span class="keyword">int</span> H[MAX_N + <span class="number">1</span>];</div><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; bucket; <span class="comment">//first存储最大值，second存储最小值</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;Q;</div><div class="line">    <span class="keyword">int</span> bucket_size = <span class="built_in">sqrt</span>((<span class="keyword">float</span>)N);</div><div class="line">    bucket.resize(bucket_size + <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bucket_size; i++) &#123;</div><div class="line">        bucket[i].first = MIN_HEIGHT;</div><div class="line">        bucket[i].second = MAX_HEIGHT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;H[i];</div><div class="line">        bucket[i / bucket_size].first = max(bucket[i / bucket_size].first, H[i]);</div><div class="line">        bucket[i / bucket_size].second = min(bucket[i / bucket_size].second, H[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++) &#123;</div><div class="line">        <span class="keyword">int</span> A, B;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B;</div><div class="line">        <span class="keyword">if</span> (A == B) &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> daming = MIN_HEIGHT, xiaoming = MAX_HEIGHT;</div><div class="line"></div><div class="line">        <span class="comment">//如果A、B在一个桶</span></div><div class="line">        <span class="keyword">while</span> (A &lt;= B &amp;&amp; A % bucket_size != <span class="number">0</span>) &#123;</div><div class="line">            daming = max(H[A], daming);</div><div class="line">            xiaoming = min(H[A], xiaoming);</div><div class="line">            A++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (A &lt;= B &amp;&amp; (B + <span class="number">1</span>) % bucket_size != <span class="number">0</span>) &#123;</div><div class="line">            daming = max(H[B], daming);</div><div class="line">            xiaoming = min(H[B], xiaoming);</div><div class="line">            B--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (A &lt;= B) &#123;</div><div class="line">            daming = max(bucket[A/bucket_size].first, daming);</div><div class="line">            xiaoming = min(bucket[A/bucket_size].second, xiaoming);</div><div class="line">            A += bucket_size;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;(daming - xiaoming)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/26/2014-10-26-Balanced-Lineup/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/26/2014-10-26-union-find/">图:并查集</a></h1><div class="post-meta">2014-10-26</div><div class="post-content"><p>并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。</p>
<p>并查集一般支持两种操作：</p>
<ol>
<li>查找    查询两个元素a和b是否在同一个集合</li>
<li>合并    合并a和b所在的两个集合</li></div><p class="readmore"><a href="/2014/10/26/2014-10-26-union-find/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/25/2014-10-25-prim-mst/">图:最小生成树之Prim算法</a></h1><div class="post-meta">2014-10-25</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">贪心算法之最小生成树</div><div class="line"></div><div class="line">伪代码：</div><div class="line">MST-PRIM（G, w, r）</div><div class="line">for each u in V[G]</div><div class="line">    do key[u] &lt;- INF</div><div class="line">    pi[u] &lt;- NIL</div><div class="line">key[r] &lt;- 0</div><div class="line">Q &lt;- V[G]</div><div class="line">while Q != EMPTY</div><div class="line">    do u &lt;- EXTRACT-MIN(Q)</div><div class="line">    for each v in Adj[u]</div><div class="line">        do if v in Q and w(u, v) &lt; key[v]</div><div class="line">            then pi[v] &lt;- u</div><div class="line">            key[v] = w(u,v)</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/25/2014-10-25-prim-mst/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-24-binary-tree-traversal/">二叉树的非递归遍历</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><p>这里给出二叉树的普通非递归遍历, 主要使用方法二就好了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">//二叉树的节点</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node *lch, *rch;</div><div class="line">    Node(<span class="keyword">int</span> x):val(x), lch(<span class="literal">NULL</span>), rch(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//前序遍历</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 方法一：</div><div class="line"> 前序遍历就是先访问当前节点，然后依次访问左子结点，右子节点</div><div class="line"> 所以很简单，我们就直接用一个栈先压入右子节点，然后压入左子结点就可以了</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; s;</div><div class="line">    Node *cur;          <span class="comment">//当前访问节点</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)   <span class="comment">//如果根节点不为空，压栈</span></div><div class="line">        s.push(root);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;    <span class="comment">//如果栈不为空</span></div><div class="line">        cur = s.top();      <span class="comment">//输出当前访问节点</span></div><div class="line">        s.pop();</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line"></div><div class="line">        <span class="comment">//依次将右子节点，左子结点压栈</span></div><div class="line">        <span class="keyword">if</span> (cur-&gt;rch != <span class="literal">NULL</span>)</div><div class="line">            s.push(cur-&gt;rch);</div><div class="line">        <span class="keyword">if</span> (cur-&gt;lch != <span class="literal">NULL</span>)</div><div class="line">            s.push(cur-&gt;lch);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> 方法二</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraversal1</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    Node *cur = root;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; st;</div><div class="line">    <span class="keyword">while</span> (!st.empty() || cur) &#123;</div><div class="line">        <span class="keyword">while</span> (cur) &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            st.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125;</div><div class="line">        cur = st.top();</div><div class="line">        st.pop();</div><div class="line">        cur = cur-&gt;rch;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 中序遍历不能像后序遍历一样记录前一个访问的节点，因为前一个访问的节点并不是要访问的节点的</div><div class="line"> 直接子节点，所以又得换种方法：</div><div class="line"> 我们用一个节点记录当前访问的节点，然后用一个栈记录上一个访问过的节点。如果当前的节点不为空，</div><div class="line"> 那么向下访问左子结点。</div><div class="line"> 如果当前访问的节点为空，说明上一个访问的节点已经没有左子结点了，那么输出上一个节点，</div><div class="line"> 然后访问上一个节点的右子节点。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; s;</div><div class="line">    Node *cur = root;       <span class="comment">//当前访问节点</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!s.empty() || cur != <span class="literal">NULL</span>) &#123; <span class="comment">//如果当前访问节点与栈都不为空</span></div><div class="line">        <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">//如果当前节点不为空，那么继续往下访问左子结点，并将当前节点压栈</span></div><div class="line">            s.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果当前节点为空，那么从栈顶弹出节点，并输出该节点，然后继续往下访问</span></div><div class="line">            <span class="comment">//右子节点</span></div><div class="line">            cur = s.top();</div><div class="line">            s.pop();</div><div class="line"></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            cur = cur-&gt;rch;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 方法二</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraversal1</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</div><div class="line">    Node *cur = root;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; st;</div><div class="line">    <span class="keyword">while</span> (!st.empty() || cur) &#123;</div><div class="line">        <span class="keyword">while</span> (cur) &#123;</div><div class="line">            st.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125;</div><div class="line">        cur = st.top();</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">        cur = cur-&gt;rch;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//后序遍历的非递归实现</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 后序遍历就是先访问节点的左子结点和右子节点，再访问当前节点</div><div class="line"> 如果不用递归，我们就可以用栈，我们可以依次将当前节点、右子节点和左子结点入栈，</div><div class="line"> 然后再弹栈</div><div class="line"> 但是这里又有另一个问题，如果我们访问到了一个节点，可是我们不知道到底是应该将它的两个子节点</div><div class="line"> 压栈还是该将它弹出。因此就需要一个辅助的节点来记录上一个弹出的节点，如果被弹出的上一个节点</div><div class="line"> 是它的一个子节点，那么说明前面已经将该节点的子节点压栈了，现在该将它弹出。问题就解决了。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; s;</div><div class="line">    Node *pre = <span class="literal">NULL</span>;   <span class="comment">//已经输出过的前一个节点</span></div><div class="line">    Node *cur = <span class="literal">NULL</span>;   <span class="comment">//当前访问的节点</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</div><div class="line">        s.push(root);       <span class="comment">//首先将根节点压栈</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">        cur = s.top();  <span class="comment">//获取栈顶的节点</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((cur-&gt;lch == <span class="literal">NULL</span> &amp;&amp; cur-&gt;rch == <span class="literal">NULL</span>) ||</div><div class="line">            (pre != <span class="literal">NULL</span> &amp;&amp; (cur-&gt;lch == pre || cur-&gt;rch == pre))) &#123;</div><div class="line">            <span class="comment">//如果当前的节点既没有左子结点又没有右子节点</span></div><div class="line">            <span class="comment">//或者当前节点的子节点已经被输出过，即已经是第二次经过该节点了</span></div><div class="line">            <span class="comment">//输出当前节点，并且将当前节点赋给pre</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            s.pop();</div><div class="line">            pre = cur;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//依次将右子节点和左子结点入栈</span></div><div class="line">            <span class="keyword">if</span> (cur-&gt;rch != <span class="literal">NULL</span>)</div><div class="line">                s.push(cur-&gt;rch);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (cur-&gt;lch != <span class="literal">NULL</span>)</div><div class="line">                s.push(cur-&gt;lch);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> 方法二</div><div class="line"> 后序遍历和中序遍历和前序遍历不同，需要保存上一个访问过的节点，</div><div class="line"> 然后根据这个节点来决定是否访问当前点</div><div class="line"> 思路就是使用两个指针，一个用来遍历，另一个用来保存前一个访问的节点</div><div class="line"> 遍历的节点先往左走到头，然后根据当前节点是否有右子节点或者右子节点是否访问过来判断是否要访问当前节点。</div><div class="line"> 否则访问右子节点</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraversal1</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</div><div class="line">    Node *cur = root, *pre = <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; st;</div><div class="line">    <span class="keyword">while</span> (!st.empty() &amp;&amp; cur) &#123;</div><div class="line">        <span class="keyword">while</span> (cur) &#123;</div><div class="line">            st.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125;</div><div class="line">        cur = st.top();</div><div class="line">        <span class="keyword">if</span> (cur-&gt;rch == <span class="literal">NULL</span> || cur-&gt;rch == pre) &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            pre = cur;</div><div class="line">            cur = <span class="literal">NULL</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            cur = cur-&gt;rch;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//层序遍历</span></div><div class="line"><span class="comment">//层序遍历跟前序遍历差不多，就是把栈换成了队列，然后左右子节点入队的顺序交换了一下</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelorderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;Node *&gt; que;</div><div class="line">    Node *cur;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</div><div class="line">        que.push(root);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</div><div class="line">        cur = que.front();</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">        que.pop();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cur-&gt;lch != <span class="literal">NULL</span>)</div><div class="line">            que.push(cur-&gt;lch);</div><div class="line">        <span class="keyword">if</span> (cur-&gt;rch != <span class="literal">NULL</span>)</div><div class="line">            que.push(cur-&gt;rch);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">Node <span class="title">root</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c1</span><span class="params">(<span class="number">2</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c2</span><span class="params">(<span class="number">3</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c3</span><span class="params">(<span class="number">4</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c4</span><span class="params">(<span class="number">5</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c5</span><span class="params">(<span class="number">6</span>)</span></span>;</div><div class="line">    root.lch = &amp;c1;</div><div class="line">    root.rch = &amp;c2;</div><div class="line">    c1.lch = &amp;c3;</div><div class="line">    c1.rch = &amp;c4;</div><div class="line">    c2.lch = &amp;c5;</div><div class="line"></div><div class="line">    preOrderTraversal(&amp;root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    preOrderTraversal1(&amp;root);</div><div class="line"></div><div class="line">    postorderTraversal(&amp;root);</div><div class="line">    inorderTraversal(&amp;root);</div><div class="line">    levelorderTraversal(&amp;root);</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/23/2014-10-24-binary-tree-traversal/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-23-Topological-sorting/">图：拓扑排序(Topological sort)</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><p>由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。</p>
<ul>
<li>每个顶点出现且只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li>
</ul></div><p class="readmore"><a href="/2014/10/23/2014-10-23-Topological-sorting/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-23-leetcode-Merge-k-Sorted-Lists/">堆排序: Merge k Sorted Lists</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p>这个题如果按照常规思路来做得话，就是将k个链表两两合并，但是这样做的时间复杂度高.</p></div><p class="readmore"><a href="/2014/10/23/2014-10-23-leetcode-Merge-k-Sorted-Lists/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/7/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ/">NSQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lintcode/">lintcode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/problems/">problems</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/二分搜索/" style="font-size: 15px;">二分搜索</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/Deque/" style="font-size: 15px;">Deque</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SkipList/" style="font-size: 15px;">SkipList</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-linux-awk/">awk</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-mysql/">mysql的一些细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/2017-05-01-nsq/">NSQD源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/2016-03-25-skip-list/">SkipList(跳表)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/2016-03-22-stack-problems/">栈的一些巧妙应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/21/2016-03-21-database-engine/">数据库索引的实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-interface/">抽象类与接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-inner-class/">内部类</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-design-pattern-strategy/">设计模式之策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/2016-03-08-detail-questions/">细节题</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://1mhz.me" title="1mhz" target="_blank">1mhz</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">雨天.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>