<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="dsfd"><title>雨天 | 行百里者半九十</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">雨天</h1><a id="logo" href="/.">雨天</a><p class="description">行百里者半九十</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2014/11/20/2014-11-20-edmonds-karp/">最大流: Edmonds-Karp算法</a></h1><div class="post-meta">2014-11-20</div><div class="post-content"><p>Edmonds-Karp算法是Ford-Fulkerson算法的一种实现，时间复杂度为$O(VE^2)$.</p>
<p>思想就是每次在源点和终点之间都找出一条增广路径，然后根据这条增广路径的容量计算图的残留网络，继续在残留网络上找增广路径，直至找不出增广路径为止，最后得到的增广路径的和即为图的最大流。</p></div><p class="readmore"><a href="/2014/11/20/2014-11-20-edmonds-karp/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/19/2014-08-28-sorting/">基础排序(sorting)</a></h1><div class="post-meta">2014-11-19</div><div class="post-content"><p>###选择排序(selection sort)</p>
<p>选择排序的思想就是每次在数组未排序部分选择最大或者最小的数值，然后将它放在正确的位置上。<br><br>代码实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (less(a[j], a[min]))</div><div class="line">                min = j;</div><div class="line">        &#125;</div><div class="line">        exch(a, i, min);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    Comparble t = a[i];</div><div class="line">    a[i] = a[j];</div><div class="line">    a[j] = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></div><p class="readmore"><a href="/2014/11/19/2014-08-28-sorting/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/18/2014-11-18-segment-tree/">数据结构：线段树(segment tree)</a></h1><div class="post-meta">2014-11-18</div><div class="post-content"><p>###线段树的概念</p>
<p>线段树是擅长处理区间的，形如下图的数据结构。线段树是一棵完美二叉树（Perfect Binary Tree)（所有的叶子的深度都相同，并且每个节点要么是叶子要么有2个儿子的树）树上的每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲的区间二等分后的其中一个子区间。当有$n$个元素时，对区间的操作可以在$O(\log{n})$的时间内完成。</p></div><p class="readmore"><a href="/2014/11/18/2014-11-18-segment-tree/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/15/2014-11-15-math-prime/">素数</a></h1><div class="post-meta">2014-11-15</div><div class="post-content"><h3 id="判断一个数是否为素数"><a href="#判断一个数是否为素数" class="headerlink" title="判断一个数是否为素数"></a>判断一个数是否为素数</h3><p>很容易想到，我们只要把$2\rightarrow n-1$遍历一遍，就可以得到一个数是否为素数。但是这样的话时间复杂度将会是O(n).再想想其实我们可以只遍历$2\rightarrow n/2$，但是这样还是$O(n)$.</p></div><p class="readmore"><a href="/2014/11/15/2014-11-15-math-prime/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/13/2014-11-13-dijkstra/">图:单源点最短路之dijkstra算法</a></h1><div class="post-meta">2014-11-13</div><div class="post-content"><p>dijkstra算法也是采用的贪心算法，和prim算法非常像，可以比较一下代码，就两三行不同。</p>
<p>思想就是根据各顶点到源点的距离生成一个优先级队列，初始时除了源点距离为零，其它都为INF。这样，每次从队列中取出最短路径的顶点，然后对每个邻接的顶点进行松弛，更新队列。重复操作直至队列为空。</p></div><p class="readmore"><a href="/2014/11/13/2014-11-13-dijkstra/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/12/2014-11-12-leetcode-Subsets/">位运算与深搜: subsets</a></h1><div class="post-meta">2014-11-12</div><div class="post-content"><p>Given a set of distinct integers, S, return all possible subsets.</p>
<p>Note:<br>Elements in a subset must be in non-descending order.</p>
<p>The solution set must not contain duplicate subsets.</p></div><p class="readmore"><a href="/2014/11/12/2014-11-12-leetcode-Subsets/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/07/2014-11-07-linux-virtual-network/">Linux网络虚拟化的一些概念</a></h1><div class="post-meta">2014-11-07</div><div class="post-content"><p>##bridge<br>Bridge（桥）是 Linux 上用来做 TCP/IP 二层协议交换的设备，与现实世界中的交换机功能相似。Bridge 设备实例可以和 Linux 上其他网络设备实例连接，既 attach 一个从设备，类似于在现实世界中的交换机和一个用户终端之间连接一根网线。当有数据到达时，Bridge 会根据报文中的 MAC</p></div><p class="readmore"><a href="/2014/11/07/2014-11-07-linux-virtual-network/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/11/01/2014-11-1-leetcode-Clone-Graph/">DFS,图: Clone Graph</a></h1><div class="post-meta">2014-11-01</div><div class="post-content"><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, UndirectedGraphNode *&gt; nodes;  <span class="comment">//定义一个map来存储label与相对应的node指针</span></div><div class="line"></div><div class="line">    <span class="comment">//使用DFS来拷贝图</span></div><div class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</div><div class="line">        <span class="comment">//！重要，如果node为空，直接返回空指针</span></div><div class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="comment">//这里不能使用UndirectedGraphNode root(node-&gt;label)，然后返回地址，</span></div><div class="line">        <span class="comment">//这样会出现runtime error</span></div><div class="line">        UndirectedGraphNode *root = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</div><div class="line">        nodes.insert(make_pair(node-&gt;label, root));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.size(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> label = node-&gt;neighbors[i]-&gt;label;</div><div class="line">            <span class="keyword">if</span> (nodes.count(label) != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//如果遍历过了，加入nieghbors</span></div><div class="line">                root-&gt;neighbors.push_back(nodes[label]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果没有遍历过，拷贝该节点</span></div><div class="line">                root-&gt;neighbors.push_back(cloneGraph(node-&gt;neighbors[i]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/11/01/2014-11-1-leetcode-Clone-Graph/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/30/2014-10-30-dag-shortest-path/">图: DAG中使用拓扑排序来求单源点最短路径</a></h1><div class="post-meta">2014-10-30</div><div class="post-content"><p>求单源点最短路径时，使用Bellman-Ford算法的需要对所有边松弛V-1遍。但是如果我们知道一个图是一个有向无环图时，我们先对所有顶点进行一次拓扑排序，然后依次对每个顶点连接的边松弛一遍就可以了。时间复杂度为O(V+E)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DAG-SHORTEST-PATHS(G, w, s)</div><div class="line">	topologically sort the vetices of G</div><div class="line">	INITIALIZE-SINGLE-SOURCE(G,s)</div><div class="line">	for each vertex u, taken in topolocially sorted order</div><div class="line">		do for each vertex v in Adj[u]</div><div class="line">			dor Relax(u, v, w)</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/30/2014-10-30-dag-shortest-path/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/30/2014-10-30-throw-disks/">扔盘子问题</a></h1><div class="post-meta">2014-10-30</div><div class="post-content"><p>题目链接：<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1279" target="_blank" rel="external">扔盘子</a></p>
<p>The story is about throwing concrete disks into an old dry well. The well is made of concrete rings that can have different (internal) diameters. The disks fall until they hit the bottom, the previously dropped disk or the concrete ring (whose internal diameter is smaller then the disk’s diameter). You are given two arrays, A containing the diameters of the rings in the top-down order, and B containing the the diameters of the disks. The task is to compute how many disks will fit into the well?</p></div><p class="readmore"><a href="/2014/10/30/2014-10-30-throw-disks/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ/">NSQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lintcode/">lintcode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/problems/">problems</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/二分搜索/" style="font-size: 15px;">二分搜索</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/Deque/" style="font-size: 15px;">Deque</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SkipList/" style="font-size: 15px;">SkipList</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/2017-05-01-nsq/">NSQD源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/2016-03-25-skip-list/">SkipList(跳表)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/2016-03-22-stack-problems/">栈的一些巧妙应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/21/2016-03-21-database-engine/">数据库索引的实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-interface/">抽象类与接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-java-inner-class/">内部类</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/2016-03-14-design-pattern-strategy/">设计模式之策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/2016-03-08-detail-questions/">细节题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/2016-03-08-design-pattern-iterator/">设计模式之迭代器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/2016-03-08-design-pattern-adapter/">设计模式之适配器模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://1mhz.me" title="1mhz" target="_blank">1mhz</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">雨天.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>