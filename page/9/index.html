<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="dsfd"><title>雨天 | 行百里者半九十</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">雨天</h1><a id="logo" href="/.">雨天</a><p class="description">行百里者半九十</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2014/10/26/2014-10-26-union-find/">图:并查集</a></h1><div class="post-meta">2014-10-26</div><div class="post-content"><p>并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。</p>
<p>并查集一般支持两种操作：</p>
<ol>
<li>查找    查询两个元素a和b是否在同一个集合</li>
<li>合并    合并a和b所在的两个集合</li></div><p class="readmore"><a href="/2014/10/26/2014-10-26-union-find/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/25/2014-10-25-prim-mst/">图:最小生成树之Prim算法</a></h1><div class="post-meta">2014-10-25</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">贪心算法之最小生成树</div><div class="line"></div><div class="line">伪代码：</div><div class="line">MST-PRIM（G, w, r）</div><div class="line">for each u in V[G]</div><div class="line">    do key[u] &lt;- INF</div><div class="line">    pi[u] &lt;- NIL</div><div class="line">key[r] &lt;- 0</div><div class="line">Q &lt;- V[G]</div><div class="line">while Q != EMPTY</div><div class="line">    do u &lt;- EXTRACT-MIN(Q)</div><div class="line">    for each v in Adj[u]</div><div class="line">        do if v in Q and w(u, v) &lt; key[v]</div><div class="line">            then pi[v] &lt;- u</div><div class="line">            key[v] = w(u,v)</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/25/2014-10-25-prim-mst/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-24-binary-tree-traversal/">二叉树的非递归遍历</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><p>这里给出二叉树的普通非递归遍历, 主要使用方法二就好了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">//二叉树的节点</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node *lch, *rch;</div><div class="line">    Node(<span class="keyword">int</span> x):val(x), lch(<span class="literal">NULL</span>), rch(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//前序遍历</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 方法一：</div><div class="line"> 前序遍历就是先访问当前节点，然后依次访问左子结点，右子节点</div><div class="line"> 所以很简单，我们就直接用一个栈先压入右子节点，然后压入左子结点就可以了</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; s;</div><div class="line">    Node *cur;          <span class="comment">//当前访问节点</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)   <span class="comment">//如果根节点不为空，压栈</span></div><div class="line">        s.push(root);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;    <span class="comment">//如果栈不为空</span></div><div class="line">        cur = s.top();      <span class="comment">//输出当前访问节点</span></div><div class="line">        s.pop();</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line"></div><div class="line">        <span class="comment">//依次将右子节点，左子结点压栈</span></div><div class="line">        <span class="keyword">if</span> (cur-&gt;rch != <span class="literal">NULL</span>)</div><div class="line">            s.push(cur-&gt;rch);</div><div class="line">        <span class="keyword">if</span> (cur-&gt;lch != <span class="literal">NULL</span>)</div><div class="line">            s.push(cur-&gt;lch);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> 方法二</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraversal1</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    Node *cur = root;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; st;</div><div class="line">    <span class="keyword">while</span> (!st.empty() || cur) &#123;</div><div class="line">        <span class="keyword">while</span> (cur) &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            st.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125;</div><div class="line">        cur = st.top();</div><div class="line">        st.pop();</div><div class="line">        cur = cur-&gt;rch;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 中序遍历不能像后序遍历一样记录前一个访问的节点，因为前一个访问的节点并不是要访问的节点的</div><div class="line"> 直接子节点，所以又得换种方法：</div><div class="line"> 我们用一个节点记录当前访问的节点，然后用一个栈记录上一个访问过的节点。如果当前的节点不为空，</div><div class="line"> 那么向下访问左子结点。</div><div class="line"> 如果当前访问的节点为空，说明上一个访问的节点已经没有左子结点了，那么输出上一个节点，</div><div class="line"> 然后访问上一个节点的右子节点。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; s;</div><div class="line">    Node *cur = root;       <span class="comment">//当前访问节点</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!s.empty() || cur != <span class="literal">NULL</span>) &#123; <span class="comment">//如果当前访问节点与栈都不为空</span></div><div class="line">        <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">//如果当前节点不为空，那么继续往下访问左子结点，并将当前节点压栈</span></div><div class="line">            s.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果当前节点为空，那么从栈顶弹出节点，并输出该节点，然后继续往下访问</span></div><div class="line">            <span class="comment">//右子节点</span></div><div class="line">            cur = s.top();</div><div class="line">            s.pop();</div><div class="line"></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            cur = cur-&gt;rch;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 方法二</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraversal1</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</div><div class="line">    Node *cur = root;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; st;</div><div class="line">    <span class="keyword">while</span> (!st.empty() || cur) &#123;</div><div class="line">        <span class="keyword">while</span> (cur) &#123;</div><div class="line">            st.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125;</div><div class="line">        cur = st.top();</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">        cur = cur-&gt;rch;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//后序遍历的非递归实现</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 后序遍历就是先访问节点的左子结点和右子节点，再访问当前节点</div><div class="line"> 如果不用递归，我们就可以用栈，我们可以依次将当前节点、右子节点和左子结点入栈，</div><div class="line"> 然后再弹栈</div><div class="line"> 但是这里又有另一个问题，如果我们访问到了一个节点，可是我们不知道到底是应该将它的两个子节点</div><div class="line"> 压栈还是该将它弹出。因此就需要一个辅助的节点来记录上一个弹出的节点，如果被弹出的上一个节点</div><div class="line"> 是它的一个子节点，那么说明前面已经将该节点的子节点压栈了，现在该将它弹出。问题就解决了。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; s;</div><div class="line">    Node *pre = <span class="literal">NULL</span>;   <span class="comment">//已经输出过的前一个节点</span></div><div class="line">    Node *cur = <span class="literal">NULL</span>;   <span class="comment">//当前访问的节点</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</div><div class="line">        s.push(root);       <span class="comment">//首先将根节点压栈</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">        cur = s.top();  <span class="comment">//获取栈顶的节点</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((cur-&gt;lch == <span class="literal">NULL</span> &amp;&amp; cur-&gt;rch == <span class="literal">NULL</span>) ||</div><div class="line">            (pre != <span class="literal">NULL</span> &amp;&amp; (cur-&gt;lch == pre || cur-&gt;rch == pre))) &#123;</div><div class="line">            <span class="comment">//如果当前的节点既没有左子结点又没有右子节点</span></div><div class="line">            <span class="comment">//或者当前节点的子节点已经被输出过，即已经是第二次经过该节点了</span></div><div class="line">            <span class="comment">//输出当前节点，并且将当前节点赋给pre</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            s.pop();</div><div class="line">            pre = cur;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//依次将右子节点和左子结点入栈</span></div><div class="line">            <span class="keyword">if</span> (cur-&gt;rch != <span class="literal">NULL</span>)</div><div class="line">                s.push(cur-&gt;rch);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (cur-&gt;lch != <span class="literal">NULL</span>)</div><div class="line">                s.push(cur-&gt;lch);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> 方法二</div><div class="line"> 后序遍历和中序遍历和前序遍历不同，需要保存上一个访问过的节点，</div><div class="line"> 然后根据这个节点来决定是否访问当前点</div><div class="line"> 思路就是使用两个指针，一个用来遍历，另一个用来保存前一个访问的节点</div><div class="line"> 遍历的节点先往左走到头，然后根据当前节点是否有右子节点或者右子节点是否访问过来判断是否要访问当前节点。</div><div class="line"> 否则访问右子节点</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraversal1</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</div><div class="line">    Node *cur = root, *pre = <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; st;</div><div class="line">    <span class="keyword">while</span> (!st.empty() &amp;&amp; cur) &#123;</div><div class="line">        <span class="keyword">while</span> (cur) &#123;</div><div class="line">            st.push(cur);</div><div class="line">            cur = cur-&gt;lch;</div><div class="line">        &#125;</div><div class="line">        cur = st.top();</div><div class="line">        <span class="keyword">if</span> (cur-&gt;rch == <span class="literal">NULL</span> || cur-&gt;rch == pre) &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">            pre = cur;</div><div class="line">            cur = <span class="literal">NULL</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            cur = cur-&gt;rch;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//层序遍历</span></div><div class="line"><span class="comment">//层序遍历跟前序遍历差不多，就是把栈换成了队列，然后左右子节点入队的顺序交换了一下</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelorderTraversal</span><span class="params">(Node *root)</span> </span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;Node *&gt; que;</div><div class="line">    Node *cur;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</div><div class="line">        que.push(root);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</div><div class="line">        cur = que.front();</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;cur-&gt;val;</div><div class="line">        que.pop();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cur-&gt;lch != <span class="literal">NULL</span>)</div><div class="line">            que.push(cur-&gt;lch);</div><div class="line">        <span class="keyword">if</span> (cur-&gt;rch != <span class="literal">NULL</span>)</div><div class="line">            que.push(cur-&gt;rch);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">Node <span class="title">root</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c1</span><span class="params">(<span class="number">2</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c2</span><span class="params">(<span class="number">3</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c3</span><span class="params">(<span class="number">4</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c4</span><span class="params">(<span class="number">5</span>)</span></span>;</div><div class="line">    <span class="function">Node <span class="title">c5</span><span class="params">(<span class="number">6</span>)</span></span>;</div><div class="line">    root.lch = &amp;c1;</div><div class="line">    root.rch = &amp;c2;</div><div class="line">    c1.lch = &amp;c3;</div><div class="line">    c1.rch = &amp;c4;</div><div class="line">    c2.lch = &amp;c5;</div><div class="line"></div><div class="line">    preOrderTraversal(&amp;root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    preOrderTraversal1(&amp;root);</div><div class="line"></div><div class="line">    postorderTraversal(&amp;root);</div><div class="line">    inorderTraversal(&amp;root);</div><div class="line">    levelorderTraversal(&amp;root);</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><p class="readmore"><a href="/2014/10/23/2014-10-24-binary-tree-traversal/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-23-Topological-sorting/">图：拓扑排序(Topological sort)</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><p>由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。</p>
<ul>
<li>每个顶点出现且只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li>
</ul></div><p class="readmore"><a href="/2014/10/23/2014-10-23-Topological-sorting/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-23-leetcode-Merge-k-Sorted-Lists/">堆排序: Merge k Sorted Lists</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p>这个题如果按照常规思路来做得话，就是将k个链表两两合并，但是这样做的时间复杂度高.</p></div><p class="readmore"><a href="/2014/10/23/2014-10-23-leetcode-Merge-k-Sorted-Lists/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/23/2014-10-23-c-traps/">c语言的一些需要注意的小问题</a></h1><div class="post-meta">2014-10-23</div><div class="post-content"><h3 id="define-square-x-x-x"><a href="#define-square-x-x-x" class="headerlink" title="#define square(x) x * x"></a>#define square(x) x * x</h3><p>如果执行的是square(z + 1),那么替换后的结果为z + 1*z + 1，结果是不对的，所以使用宏的时候还是得非常小心。</p></div><p class="readmore"><a href="/2014/10/23/2014-10-23-c-traps/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/20/2014-10-20-Polish-notation/">四则运算计算器实现</a></h1><div class="post-meta">2014-10-20</div><div class="post-content"><p>##波兰表示法与逆波兰表示法</p>
<p><em>波兰表示法</em>（Polish notation，或波兰记法），是一种逻辑、算术和代数表示方法，其特点是操作符置于操作数的前面，因此也称做前缀表示法。与逆波兰表示法不同，前缀表达式基本没有在商业计算器中使用过，但是其体系经常在编译器构造的概念教学中首先使用。</p></div><p class="readmore"><a href="/2014/10/20/2014-10-20-Polish-notation/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/16/2014-10-16-binary-search-tree/">二叉搜索树(binary search tree)</a></h1><div class="post-meta">2014-10-16</div><div class="post-content"><p>##二叉搜索树</p>
<p>二叉搜索树又叫二叉查找树，是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li></div><p class="readmore"><a href="/2014/10/16/2014-10-16-binary-search-tree/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/16/2014-10-16-stl-iterator-pointer/">iterator和指针</a></h1><div class="post-meta">2014-10-16</div><div class="post-content"><p>##Iterator</p>
<p>iterator一般用在容器中，下面是所有容器都支持的一些运算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*iter 返回迭代器 iter 所指向的元素的引用</div><div class="line"></div><div class="line">iter-&gt;mem 对 iter 进行解引用，获取指定元素中名为 mem 的成员。等效于 (*iter).mem</div><div class="line"></div><div class="line">++iter iter++ 给 iter 加 1，使其指向容器里的下一个元素</div><div class="line"></div><div class="line">--iter iter-- 给 iter 减 1，使其指向容器里的前一个元素</div><div class="line"></div><div class="line">iter1 == iter2</div><div class="line">iter1 != iter2  比较两个迭代器是否相等（或不等）。当两个迭代器指向同一个容器中的同一个元素，或者当它们都指向同一个容器的超出末端的下一位置时，两个迭代器相等</div></pre></td></tr></table></figure></p></div><p class="readmore"><a href="/2014/10/16/2014-10-16-stl-iterator-pointer/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2014/10/14/2014-10-14-bipartite-graph/">图: 二分图(用邻接表实现)</a></h1><div class="post-meta">2014-10-14</div><div class="post-content"><p>给定一个具有n个顶点的图。要给图上每个顶点染色，并且要使相邻的顶点颜色不同。问是否能最多使用2种颜色进行染色？题目保证没有重边和自环。</p>
<p>这个题可以使用dfs来实现，思路还是挺简单的。</p>
<p>假设有一个简单图，随意从一个顶点开始染色，然后给相邻的顶点染上相反的色，如果相邻顶点和自己的色相同，那么说明不是二分图。</p></div><p class="readmore"><a href="/2014/10/14/2014-10-14-bipartite-graph/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ/">NSQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lintcode/">lintcode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/problems/">problems</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/二分搜索/" style="font-size: 15px;">二分搜索</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/Deque/" style="font-size: 15px;">Deque</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SkipList/" style="font-size: 15px;">SkipList</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/07/2017-10-07-docker-ethereum/">基于Docker的Ethereum 开发环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/2017-06-26-go-profile/">go 基准测试和pprof的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/2017-06-26-go-malloc/">go内存分配</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/19/2017-06-19-ratelimiter/">Ratelimter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/03/2017-06-03-vm/">虚拟存储器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-linux-awk/">awk</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/2017-05-06-mysql/">mysql的一些细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/2017-05-01-nsq/">NSQD源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/2016-03-25-skip-list/">SkipList(跳表)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/2016-03-22-stack-problems/">栈的一些巧妙应用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://1mhz.me" title="1mhz" target="_blank">1mhz</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">雨天.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>